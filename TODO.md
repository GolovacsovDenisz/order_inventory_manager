


Итерация 2 — Доменные модели + мок-репозитории (0.5–1 день)

Цель: чтобы UI уже показывал “реальные” списки, но пока из моков.
	•	Модели: Order, Product, Client, enum OrderStatus
	•	Репозитории интерфейсами: OrdersRepository, ProductsRepository, ClientsRepository
	•	Мок-реализация (list in memory)
	•	UI списков: loading/empty/error (пока error можно симулировать)

Готово: списки работают, CRUD можно сделать “локально” без API.

⸻

Итерация 3 — REST API слой (1–2 дня)

Цель: подключить настоящий API (мок-сервер) с обработкой ошибок.
	•	Dio клиент + перехватчики (логирование, baseUrl)
	•	DTO + маппинг в доменные модели
	•	Реальные ...RepositoryImpl
	•	Обработка ошибок: timeouts/500/нет сети → дружелюбные сообщения

Готово: данные грузятся с API, pull-to-refresh, error states.

⸻

Итерация 4 — Локальное хранение (0.5–1 день)

Цель: “вкус портфолио”: кеш + сохранение настроек.
	•	SharedPreferences: последние фильтры/сортировка/поиск по каждой вкладке
	•	Hive: кеш списков (например, last successful response)
	•	Стратегия: показываем кеш мгновенно → затем обновляем из сети

Готово: при перезапуске приложения фильтры сохраняются, списки могут появиться сразу.

⸻

Итерация 5 — Фичи “как в заказе” (2–4 дня)

Orders
	•	CRUD с формой (валидации)
	•	статус, сумма/цена, дата
	•	поиск + фильтры + сортировка
	•	empty/error states, snackbar, confirm delete

Products
	•	CRUD, цена, stock
	•	сортировка/поиск

Clients
	•	CRUD, телефон, заметки
	•	поиск

⸻

Итерация 6 — Полировка и “наносим лоск на резюме” (1–2 дня)
	•	единые компоненты: EmptyState, ErrorView, AppSearchField, ConfirmDialog
	•	skeleton loaders
	•	UX: keyboard actions, input masks для телефона, формат цены
	•	README: фичи, архитектура, скрины, как запустить mock API
	•	(опционально) мини-тесты: 2–3 unit на репо + 1 widget test на списоadf


	